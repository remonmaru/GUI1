//-----------------------------------------------------
//製作日:10/14
//製作者:Y.Kuwakami
//内容:盤面変換2
//-----------------------------------------------------
//-----------------------------------------------------

//コメント/////////////////////////////////////////////
///////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////

//ヘッダインクルード///////////////////////////////////////
///////////////////////////////////////////////////////
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <ctime>

using namespace std;
///////////////////////////////////////////////////////

//キーワード///////////////////////////////////////////
///////////////////////////////////////////////////////

#define FOR(i,a,b) for (ll i = (a); i < (b); i++)
#define REP(i,n) FOR(i,0,n)
typedef long long ll;

///////////////////////////////////////////////////////

//プロトタイプ宣言/////////////////////////////////////
///////////////////////////////////////////////////////
void make_newpos();
///////////////////////////////////////////////////////

//グローバル変数///////////////////////////////////////
///////////////////////////////////////////////////////

int W, H;
int field[15][15];
pair< int, int > p[2][2];
bool Tflag = false;
bool Yflag = false;


///////////////////////////////////////////////////////

//メイン関数///////////////////////////////////////////
///////////////////////////////////////////////////////
int main(){
    
    //入力部
    cin >> H >> W;
    REP( i, H ) REP( j, W ) cin >> field[i][j];
    
    REP( i, 2){
        cin>>p[0][i].second>>p[0][i].first;
        p[0][i].first--;
        p[0][i].second--;
    }
    
    //相手の駒の位置を予測
    make_newpos();
    
    //出力部
    cout << W << " " << H << endl;
    REP( i, H ) REP( j, W ) cout<<field[i][j]<<((j == W-1) ? '\n' : ' ');
    REP( i, 2 ) REP( j, 2 ) cout << p[i][j].first << " " << p[i][j].second << endl;
    
}

///////////////////////////////////////////////////////

//関数/////////////////////////////////////////////////
///////////////////////////////////////////////////////
void make_newpos(){
    REP( i, H/2){
        REP(j, W){
            if( field[i][j] != field[H-i-1][j] ) Tflag = true;
            if( Tflag ) break;
        }
    }
    
    REP( i, H ){
        REP( j, W/2 ){
            if( field[i][j] != field[i][W-j-1] ) Yflag = true;
            if( Yflag ) break;
        }
    }
    
    if( Yflag && !Tflag ){
        REP( i, 2 ){
            p[1][i].first = p[0][i].first;
            p[1][i].second = H-p[0][i].second-1;
        }
    }
    else if( !Yflag && Tflag){
        REP( i, 2 ){
            p[1][i].first = W-p[0][i].first-1;
            p[1][i].second = p[0][i].second;
        }
    }
    
    else{
        if( p[0][0].first == p[0][1].first ){
            REP( i, 2 ){
                p[1][i].first = W-p[0][i].first-1;
                p[1][i].second = p[0][i].second;
            }
        }
        else{
            REP( i, 2 ){
                p[1][i].first = p[0][i].first;
                p[1][i].second = H-p[0][i].second-1;
            }
        }
        
    }
}
///////////////////////////////////////////////////////
